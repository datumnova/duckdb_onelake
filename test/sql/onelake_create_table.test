# name: test/sql/onelake_create_table.test
# description: Test CREATE TABLE for OneLake extension
# group: [sql]

# Require statement will check for OneLake credentials
require onelake

require-env ONELAKE_TEST_WORKSPACE_ID

require-env ONELAKE_TEST_LAKEHOUSE_NAME

# Attach to test workspace
statement ok
ATTACH 'onelake://${ONELAKE_TEST_WORKSPACE_ID}' AS onelake_test (TYPE ONELAKE);

# Use the test lakehouse
statement ok
USE onelake_test.${ONELAKE_TEST_LAKEHOUSE_NAME};

# Test 1: Create basic table with common types
statement ok
CREATE TABLE test_basic_types (
    id INTEGER,
    name VARCHAR,
    value DOUBLE,
    is_active BOOLEAN,
    created_date DATE,
    updated_at TIMESTAMP
);

# Verify table exists by querying it (empty table)
query I
SELECT COUNT(*) FROM test_basic_types;
----
0

# Test 2: Create table with all supported numeric types
statement ok
CREATE TABLE test_numeric_types (
    col_int8 TINYINT,
    col_int16 SMALLINT,
    col_int32 INTEGER,
    col_int64 BIGINT,
    col_float FLOAT,
    col_double DOUBLE
);

query I
SELECT COUNT(*) FROM test_numeric_types;
----
0

# Test 3: Create table with DECIMAL types
statement ok
CREATE TABLE test_decimal_types (
    amount_small DECIMAL(10,2),
    amount_medium DECIMAL(18,4),
    amount_large DECIMAL(38,10)
);

query I
SELECT COUNT(*) FROM test_decimal_types;
----
0

# Test 4: Create partitioned table
statement ok
CREATE TABLE test_partitioned (
    id INTEGER,
    category VARCHAR,
    region VARCHAR,
    amount DOUBLE,
    event_date DATE
) WITH (partition_columns = 'category, region');

# Verify partitioned table schema
query I
SELECT COUNT(*) FROM test_partitioned;
----
0

# Test 5: Create table with comment
statement ok
CREATE TABLE test_with_comment (
    id INTEGER,
    value VARCHAR
) COMMENT 'Test table with description';

query I
SELECT COUNT(*) FROM test_with_comment;
----
0

# Test 6: Duplicate table error
statement error
CREATE TABLE test_basic_types (id INTEGER);
----
Table with name "test_basic_types" already exists

# Test 7: CREATE TABLE IF NOT EXISTS (should succeed)
statement ok
CREATE TABLE IF NOT EXISTS test_basic_types (id INTEGER);

# Test 8: Insert data into created table to verify write path
statement ok
INSERT INTO test_basic_types VALUES 
    (1, 'Alice', 100.5, true, DATE '2024-01-01', TIMESTAMP '2024-01-01 10:00:00'),
    (2, 'Bob', 200.75, false, DATE '2024-01-02', TIMESTAMP '2024-01-02 11:30:00');

# Verify inserted data
query IIIRBT
SELECT * FROM test_basic_types ORDER BY id;
----
1	Alice	100.5	true	2024-01-01	2024-01-01 10:00:00
2	Bob	200.75	false	2024-01-02	2024-01-02 11:30:00

# Test 9: Create and insert into partitioned table
statement ok
INSERT INTO test_partitioned VALUES 
    (1, 'A', 'US', 100.0, DATE '2024-01-01'),
    (2, 'A', 'EU', 150.0, DATE '2024-01-02'),
    (3, 'B', 'US', 200.0, DATE '2024-01-03');

query IIIIR
SELECT * FROM test_partitioned ORDER BY id;
----
1	A	US	100.0	2024-01-01
2	A	EU	150.0	2024-01-02
3	B	US	200.0	2024-01-03

# Test 10: Create table with PARTITION BY syntax
statement ok
CREATE TABLE test_partition_by_syntax (
    id INTEGER,
    category VARCHAR,
    region VARCHAR,
    amount DOUBLE,
    event_date DATE
) PARTITION BY (category, region);

# Verify PARTITION BY table works
statement ok
INSERT INTO test_partition_by_syntax VALUES 
    (1, 'Electronics', 'US', 100.0, DATE '2024-01-01'),
    (2, 'Electronics', 'EU', 150.0, DATE '2024-01-02'),
    (3, 'Furniture', 'US', 200.0, DATE '2024-01-03');

query IIIIR
SELECT * FROM test_partition_by_syntax ORDER BY id;
----
1	Electronics	US	100.0	2024-01-01
2	Electronics	EU	150.0	2024-01-02
3	Furniture	US	200.0	2024-01-03

# Cleanup: Drop test tables
statement ok
DROP TABLE test_basic_types;

statement ok
DROP TABLE test_numeric_types;

statement ok
DROP TABLE test_decimal_types;

statement ok
DROP TABLE test_partitioned;

statement ok
DROP TABLE test_partition_by_syntax;

statement ok
DROP TABLE test_with_comment;
