# name: test/sql/onelake_update_explain.test
# description: Test EXPLAIN UPDATE operations on OneLake tables to verify planning
# group: [sql]

require onelake

statement ok
SET onelake_allow_destructive_operations = true;

# Create a secret with fake credentials
statement ok
CREATE SECRET onelake_fake (
    TYPE ONELAKE,
    TENANT_ID 'fake-tenant',
    CLIENT_ID 'fake-client',
    CLIENT_SECRET 'fake-secret'
);

# Attach a fake lakehouse
# This might fail if ATTACH tries to validate immediately, but let's try.
# If ATTACH fails, we can't test UPDATE planning.
# But based on the code, it seems lazy.
statement ok
ATTACH 'workspace/lakehouse.Lakehouse' AS onelake_db (TYPE ONELAKE);

statement ok
USE onelake_db.default;

# We need a table to update. Since we can't discover tables without creds,
# we might need to rely on the fact that we can reference a table that doesn't exist
# and see if it fails at binding (Table not found) or earlier.
# But wait, if the table is not found in the catalog, we can't update it.

# OneLakeCatalog::ScanSchemas might be called.

# If we can't easily mock the catalog, we might just have to rely on the code review and the fact that I removed the exception.
